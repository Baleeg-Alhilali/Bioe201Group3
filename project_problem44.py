{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "7404330d",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "35\n",
      "ACGAACT-ATTGTTGATAACCAAGTTTCATCTAGACG-GCGTGCGGGTCGTCAAAAAAAT--AGTGA-AAGC-CATTCC-TTATCATGTGTTCTCTACTAC-GCGCCAACGGGAGAGTCAC-G-CGTCGGGTTCGGAGTGATCAATAT-CACTCCTCAAACAATATTGGACAGA--ACGCTACAACCCA-CTCC-TTGATCCTAG-GGC-GC-CCATCCGGTGGCAAGATCCAG-A-GTTGGGTGGTC-GTTCTTAAG-G-GGTCGAAAATG\n",
      "ACGGACTGATCGTTGAT--CCAAGTATC-TCTAGCCGTGCG-GCGGGCCTTTAAAAAAATAGAGCGAGAA-CTCAGTCCGTGACCATGT-TTCT-TTTTACAAC-TCAGC-TGA-AGTCACAGCCGTCGAG-TC-GAGTCAGCAAAATCCACTCCGCAAACAATATGGGAC-GACTAC-C-GCAACACATC-CCGTTGATCCTAGACGCATCGCCACCCGGTATC-AGATCCGGAACG-TGGGCGG-CGGTTCTTTAGTGTGCT-G-AAACG\n"
     ]
    }
   ],
   "source": [
    "#Finding a highest-scoring overlap alignment of two strings \n",
    "\n",
    "def overlap_alignment (sequence_1, sequence_2):\n",
    "    sequence_1='-'+sequence_1 #also known as v\n",
    "    sequence_2='-'+sequence_2 #also known as w\n",
    "    \n",
    "    score_matrix=[[0 for j in range(len(sequence_2))] for i in range(len(sequence_1))] #at the whole length of string 1 we have 0 for j\n",
    "    backtrack_matrix=[[None for j in range(len(sequence_2))] for i in range(len(sequence_1))] #at the whole length of string 1 we have no direction for j\n",
    "    \n",
    "    #penalty is 1 if we have a match \n",
    "    #penalty is -2 if we have a mismatch/indel\n",
    "    \n",
    "    for j in range(1, len(sequence_2)):\n",
    "        score_matrix[0][j]=score_matrix[0][j-1]-2 #applying the penalty 2 at point(0,j-1)\n",
    "        backtrack_matrix[0][j]='left' #the direction is left between (i,j-1) and (i,j)\n",
    "        \n",
    "    for i in range(1,len(sequence_1)): #comparing between both strings here\n",
    "        for j in range(1, len(sequence_2)):\n",
    "            #scoring_matrix cases\n",
    "            case_1=score_matrix[i-1][j-1]+(1 if sequence_1[i]==sequence_2[j] else -2) #our case is looking for a match, we add 1 if we find it and we subtract 2 if we don't (penalties)\n",
    "            case_2=score_matrix[i-1][j] -2 #applying the penalty -2 if we have an indel at (i-1,j)\n",
    "            case_3=score_matrix[i][j-1] -2 #applying the penalty -2 if we have an indel at (i,j-1)\n",
    "            \n",
    "            #back_track matrix cases\n",
    "            score_matrix[i][j]=max(case_1,case_2,case_3) #highest score\n",
    "            if score_matrix[i][j]==case_1:\n",
    "                backtrack_matrix[i][j]='diagonal' #if both sequences are equal we go diagonaly\n",
    "                \n",
    "            elif score_matrix[i][j]==case_2:\n",
    "                backtrack_matrix[i][j]='upwards'#the direction is upwards between (i,j-1) and (i,j)\n",
    "                \n",
    "            elif score_matrix[i][j]==case_3:\n",
    "                backtrack_matrix[i][j]='left'   #the direction is left between (i,j-1) and (i,j)\n",
    "      \n",
    "    \n",
    "    i=len(sequence_1)-1 #the whole sequence, -1 as the last point\n",
    "    j=max(range(len(sequence_2)), key=lambda x:score_matrix[i][x]) #key is used to determine the maximum value in the range, based on score_matrix[i][j]\n",
    "    #j represents the index where the maximum value in score_matrix[i][j] is found\n",
    "    maximum_score=score_matrix[i][j]\n",
    "    \n",
    "    #back_track\n",
    "    \n",
    "    alignment_case1=''\n",
    "    alignment_case2=''\n",
    "    while backtrack_matrix[i][j] is not None:\n",
    "        direction=backtrack_matrix[i][j]\n",
    "        if direction=='diagonal': #the case where we have a match\n",
    "            alignment_case1=sequence_1[i]+ alignment_case1\n",
    "            alignment_case2=sequence_2[j]+ alignment_case2\n",
    "            i-=1\n",
    "            j-=1\n",
    "            \n",
    "        elif direction=='upwards': #the case where we have an indel(specifically a deletion)\n",
    "            alignment_case1=sequence_1[i]+ alignment_case1\n",
    "            alignment_case2='-'+ alignment_case2\n",
    "            i-=1\n",
    "            \n",
    "        elif direction=='left':#the case where we have an indel(specifically an insertion)\n",
    "            alignment_case1='-'+ alignment_case1\n",
    "            alignment_case2=sequence_2[j]+ alignment_case2\n",
    "            j-=1\n",
    "        \n",
    "        \n",
    "    return maximum_score,alignment_case1,alignment_case2\n",
    "\n",
    "#Main Function\n",
    "if __name__=='__main__':\n",
    "    \n",
    "    sequence_1='GCACGCCCTATGGCAGGAGGGATCAACCTGATATGCGCCGTCTCAGGGCCTTGTGGTAGAGACGTACGTCTTAACCAATGGGGGATACTACGTCTGGTGACTCTCAAACTTTCTGTAGGCATAGCTACTAAGCCCGCTAATTTAGCCCCGGTGGATTACTCACGCAGGTGCTCCCCGCCAGTAAGAGAATTCGGCTTATACATAATTCTACTGTTTTAGTCATCGCGGGGGGATCATCCTAGTCACTAATCATACCATATCCCGGTTCGCGTTATGCGTACTCGCTGACTGGAATGGCTATGTACGCCAATGCCTTTGGATATGATAGTTTGCGACAACGACAAGTCACCGTTTAAAACTTTCATTTTTACTCGGATGAGCTGGCGCCAATCCTCTCGTGGAGACCAGCAGAATTAGAGCGCTCGAACGCTTTACTTTGTCGGTCGGGAGAGACTCTATTATTGCATAAGCTAGCTTAAACTACGCCGCTGGTCTCTTGCATGCTCTAAACGATTCTAGCCTATGCGGACGTCCAGCCGCGTCAGGACCACCTGCACGGTCACTAATTAATTTACTCCTGAAGTTGCCTGTGCCCGGACATGCAAAGTGAACGAACTATTGTTGATAACCAAGTTTCATCTAGACGGCGTGCGGGTCGTCAAAAAAATAGTGAAAGCCATTCCTTATCATGTGTTCTCTACTACGCGCCAACGGGAGAGTCACGCGTCGGGTTCGGAGTGATCAATATCACTCCTCAAACAATATTGGACAGAACGCTACAACCCACTCCTTGATCCTAGGGCGCCCATCCGGTGGCAAGATCCAGAGTTGGGTGGTCGTTCTTAAGGGGTCGAAAATG'\n",
    "    sequence_2='ACGGACTGATCGTTGATCCAAGTATCTCTAGCCGTGCGGCGGGCCTTTAAAAAAATAGAGCGAGAACTCAGTCCGTGACCATGTTTCTTTTTACAACTCAGCTGAAGTCACAGCCGTCGAGTCGAGTCAGCAAAATCCACTCCGCAAACAATATGGGACGACTACCGCAACACATCCCGTTGATCCTAGACGCATCGCCACCCGGTATCAGATCCGGAACGTGGGCGGCGGTTCTTTAGTGTGCTGAAACGCGGAAAGGGATCAGAGAAGATCCGCGCCGGGCGCTTCCGTTCTAGTGTTGTGTCAATGAACAGAGGGTCGGCACTATGGTACCGATGTTTCCCTTTCTCATTAATGACGTGGTTTGTACAGCCTGTTTCGACAAGGCGCATTGGCTTCCTGCACCGCATCGCGGCAACTGTTCTGACTCCTTGCCACAGCTCGAAACAAGTCCCTCCGAGTCCTTGCACAGCAGGGGCCGGAAACGTCGAATTCCGGTAGCAATATCATCTCCCCGTTAGTCAATCGGACTCCGCTTATCAACGTGGTCTATTGCTGGCGGCTTTTAGCAAGTTTCCCCCGCATGCGCTAGTGTCCCGAACCTGTCCACAAGCGCCCGTTGGTAATATGACCAATACGTTTCATTCACTTTCGACGCCCCCGATTGAACCTTGAATAACACTCCGGGTAAGGTATTTCCGAGAGTTCTCGAATGGGCTTAAAACGTTGAAGAGTGGGCTACTCTAGAGTCGGATTGCAGCCGTTAATGCCAGGCCAAATCGCGCATCGCTTTATATTTCAAGACCTGCTTTCGGGCGTGTGGTTATACGCAATATACGTCCGATTGCACTATACATTCCATTTGGTCCTTAAGGTGACAAAGCTACAATAATAACGTCGGGCAAGACCCAAATACAACCGCTTCGGCCGGCCGTAGTCCTAGCATTTGAAGGCTACCTTCAAGAC'\n",
    "\n",
    "\n",
    "    score,alignment1,alignment2=overlap_alignment(sequence_1,sequence_2)\n",
    "    \n",
    "    print(score)\n",
    "    print(alignment1)\n",
    "    print(alignment2)\n",
    "\n",
    "\n",
    "            \n",
    "                \n",
    "                \n",
    "            \n",
    "            \n",
    "    \n",
    "    "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fcd86c95",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "715a98ba",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
